#!/usr/bin/env node


//Module dependencies.
var app = require('../app');
var debug = require('debug')('textexpress:server');

//Get port from environment and store in Express.
var port = normalizePort(process.env.PORT || '27000');
app.set('port', port);

//Create HTTP server.
//Library imports(http, express, websocket)
const http = require('http');
const websocketServer = require("websocket").server
var path = require('path');
const stateMac = require('../public/javascripts/stateMachine');

//Express Start
//handled in app.js

//HTTP server start
const httpServer = http.createServer(app);
httpServer.listen(27000, () => console.log("Http on: 27000"));
httpServer.on('error', onError);
httpServer.on('listening', onListening);

//Variables
// player id placeholder
var pId = 1;
var hostKey = "not host";
//Objects for games and players used with their IDs as index
const players = {};
const games = {};

// Include for function to create random and unique game id 
var createId = require('../public/javascripts/createId');

//var StateMachine = require('javascript-state-machine');

// Turn Http into WebSocket
const wsServer = new websocketServer({
		"httpServer": httpServer,
		});

//Run Websocket
wsServer.on("request", request => {


		var playerId = pId;

		//Binding TCP to connection
		const connection = request.accept(null, request.origin);

		connection.on("close", () => {
				if(hostKey === "not host"){
				console.log("PlayerID: " + playerId + " disconnected.")}
				else {
				console.log("Created Game and Disconnected " + playerId)}
				});
    
		// receive message from the client here
		connection.on("message", message => {

				//Converts JSON message from the browser into javascript object using parse() method
				const result = JSON.parse(message.utf8Data)

				//Host game server logic
				if (result.method === "host") {
				//gets player id
				playerId = 0;

				// Generate unique game ID 
				const gameId = createId.createId(Object.keys(games));
		
				hostKey = "host";

				games[gameId] = {
				"id": gameId,
				//Card amount in game hardcoded as of now
				"cards": 4,
				//the players connected to game stored in an array
				"players": [],
				// board state 2x2 array [name, die, colors]
				"boardState":  result.boardState,
				"chatLog": []
				}

					//Data sent to player
					const gameData = {
						"method": "host",
						"game": games[gameId],
						"id": gameId,
						"boardState": games[gameId].boardState
					}
				//Send game id back to webpage
					connection.send(JSON.stringify(gameData));
				}


				if(result.method === "host-join"){
					hostKey = "host";
					const gameId = result.gameId;
					const playerId = result.playerId;

					games[gameId] = {
						"id": gameId,
						"players": [],
						"boardState": result.boardState,
						"chatLog": []
					}

					games[gameId].players.push({
						"playerId": playerId
					})


					//if there is no game, return
					if(!games[gameId]) return;

					//Data sent to player
					const gameData = {
						"method": "host-join",
						"game": games[gameId],
						"id": gameId,
						"boardState": games[gameId].boardState,
						"chatLog": games[gameId].chatLog,
						"players": games[gameId].players

					}
					//Send game id back to webpage
					connection.send(JSON.stringify(gameData));

					//Announce new connections
					let chatMessage = "Player " + playerId + ": has started the game.";
					games[gameId].chatLog.push(chatMessage);
					const game2Data = {
						"method": "updateChat",
						"chatMessage": chatMessage
					}
					games[gameId].players.forEach( p => {
						players[p.playerId].connection.send(JSON.stringify(game2Data));
					})
					// if 2 players or more join, start game
					broadcastState();


				}


				//Join game server logic
				if (result.method === "join") {

					playerId = result.playerId;
					hostKey = "not host";
					pId++;
					const gameId = result.gameId;

					//if there is no game, return
					if(!games[gameId]) return;
					// Add player to game
					games[gameId].players.push({
							"playerId": playerId
							})
					//Data sent to player to set up game
					const joinData = {
						"method": "join",
						"boardState": games[gameId].boardState,
						"chatLog": games[gameId].chatLog,
						"players": games[gameId].players,
						"id": gameId
					}
					players[playerId].connection.send(JSON.stringify(joinData));

					//Announce new connections
					let chatMessage = "Player " + playerId + " has joined.";
					games[gameId].chatLog.push(chatMessage);
					const gameData = {
						"method": "updateChat",
						"chatMessage": chatMessage
					}
					games[gameId].players.forEach( p => {
							players[p.playerId].connection.send(JSON.stringify(gameData));
							})
					// if 2 players or more join, start game
					broadcastState();
				}

				//Play game server logic
				if (result.method === "play") {

					//Itterates over the cards on the board, sends them to the statemachine to see
					//if action is permittable, if not it revertse change to old state.
					stateMac.dieCheck(result.boardState, games[result.gameId].boardState)

					playerId = result.playerId;
					const gameId = result.gameId;
					let chatMessage = null;
					let oldBoardState = games[gameId].boardState;
					let newBoardState = result.boardState;
					// Update log when a player makes a move
					// These for loops iterate over previous boardstate and compare it
					// to new boardstate to log specific changes.
					for(let i = 0; i < oldBoardState.length; ++i) {
						let oldMove = oldBoardState[i].moveMade;
						let newMove = newBoardState[i].moveMade;
						if(oldMove !== newMove) {
							chatMessage = "Player " + playerId + " " + newMove;
						}					
					}
					games[gameId].boardState = result.boardState;
					if(chatMessage !== null) {
						games[gameId].chatLog.push(chatMessage);
						const gameData = {
							"method": "updateChat",
							"chatMessage": chatMessage
						}
						games[gameId].players.forEach( p => {
								players[p.playerId].connection.send(JSON.stringify(gameData));
								})
					}
				}

				// Send game information to player for download
				if(result.method == "download") {
					const gameId = result.gameId;
					playerId = result.playerId;
					const gameData = {
						"method": "download",
						"chatLog": games[gameId].chatLog
					}
					const con = players[playerId].connection;
					con.send(JSON.stringify(gameData));
				}

				// Update logs when someone types a message
				if(result.method === 'chat') {
					let gameId = result.gameId;
					let chatMessage = result.chatMessage;
					games[gameId].chatLog.push(chatMessage);
					const gameData = {
						"method": "updateChat",
						"chatMessage": chatMessage
					}
					games[gameId].players.forEach( p => {
							players[p.playerId].connection.send(JSON.stringify(gameData));
							})
				}

				if(result.method === "exit") {

					const gameId = result.gameId;
					const playerId = result.playerId;
					
					// TODO remove player from players object
					console.log("before: " + Object.keys(players));
					delete players[playerId];
					console.log("after: " + Object.keys(players));
					if(games[gameId] !== null) {
						for(let i = 0; i < games[gameId].players.length; i++){ 
							if (games[gameId].players[i].playerId === playerId) { 
								games[gameId].players.splice(i, 1); 
							}
						}
						if(games[gameId].players.length !== 0) {
							let chatMessage = "Player " + playerId + " has left the game.";
							games[gameId].chatLog.push(chatMessage);
							const gameData = {
								"method": "updateChat",
								"chatMessage": chatMessage,
								"id": gameId
							}
														
							games[gameId].players.forEach( p => {
								players[p.playerId].connection.send(JSON.stringify(gameData));
								})
						}
						// TODO if there are no more players, end the game and remove from games object
						else {	
							console.log("IT IS GETTING HERE!")
			
							const gameData = {
								"method": "end",
								"id": gameId
							}
							
							console.log(gameData);
							//Send game id back to webpage
							connection.send(JSON.stringify(gameData));
							console.log("IT IS GETTING PAST THE CONNECTION SEND");
							
							delete games[gameId];
							console.log("IT IS GETTING PAST delete games[gameId]");
						}
					}

				} 


		})

		// generate player id
		if(playerId != 0 || hostKey === "not host"){
			playerId++;
		}

		players[playerId] = {
			"connection": connection
		}

		// data pack sent to player
		const gameData = {
			"method": "connect",
			"playerId": playerId
		}

		//pack up gameData to JSON string
		connection.send(JSON.stringify(gameData))

})


//Broadcasting function, broadcasts the gamestate to all players
function broadcastState(){

	for (const g of Object.keys(games)) {
		//update gamestate
		const game = games[g]

			const gameData = {
				"method": "update",
				"game": game
			}
		//Send updated game to all players
		game.players.forEach( p => {
				players[p.playerId].connection.send(JSON.stringify(gameData));
				})
	}

	setTimeout(broadcastState, 500);

}

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
	var port = parseInt(val, 10);

	if (isNaN(port)) {
		// named pipe
		return val;
	}

	if (port >= 0) {
		// port number
		return port;
	}

	return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
	if (error.syscall !== 'listen') {
		throw error;
	}

	var bind = typeof port === 'string'
		? 'Pipe ' + port
		: 'Port ' + port;

	// handle specific listen errors with friendly messages
	switch (error.code) {
		case 'EACCES':
			console.error(bind + ' requires elevated privileges');
			process.exit(1);
			break;
		case 'EADDRINUSE':
			console.error(bind + ' is already in use');
			process.exit(1);
			break;
		default:
			throw error;
	}
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
	var addr = httpServer.address();
	var bind = typeof addr === 'string'
		? 'pipe ' + addr
		: 'port ' + addr.port;
	debug('Listening on ' + bind);
}