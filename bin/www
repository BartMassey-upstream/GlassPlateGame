#!/usr/bin/env node


//Module dependencies.
var app = require('../app');
var debug = require('debug')('textexpress:server');

//Get port from environment and store in Express.
var port = normalizePort(process.env.PORT || '27000');
app.set('port', port);


//Create HTTP server.
//Library imports(http, express, websocket)
const http = require('http');
const websocketServer = require("websocket").server
var path = require('path');
const stateMac = require('../public/javascripts/stateMachine');


//Express Start
//handled in app.js

//HTTP server start
const httpServer = http.createServer(app);
httpServer.listen(27000, () => console.log("Http on: 27000"));
httpServer.on('error', onError);
httpServer.on('listening', onListening);

//Variables
// player id placeholder
var pId = 1;
var hostKey = "not host";
//Objects for games and players used with their IDs as index
const players = {};
const games = {};
var countForIds = [];

// Include for function to create random and unique game id 
var createId = require('../public/javascripts/createId');

//var StateMachine = require('javascript-state-machine');



// Turn Http into WebSocket
const wsServer = new websocketServer({
		"httpServer": httpServer,
		});

//Run Websocket
wsServer.on("request", request => {

		var playerId = pId;
	

		//Binding TCP to connection
		const connection = request.accept(null, request.origin);

		connection.on("close", () => {
				if(hostKey === "not host"){
				console.log("PlayerID: " + playerId + " disconnected.")}
				else {
				console.log("Created Game and Disconnected " + playerId)}
				});
    
		// receive message from the client here
		connection.on("message", message => {

				//Converts JSON message from the browser into javascript object using parse() method
				const result = JSON.parse(message.utf8Data)

				//Host game server logic
				if (result.method === "host") {
				//gets player id
				playerId = 0;

				// Generate unique game ID 
				const gameId = createId.createId(Object.keys(games));
		
				hostKey = "host";

				games[gameId] = {
				"id": gameId,
				//Card amount in game hardcoded as of now
				"cards": 4,
				//the players connected to game stored in an array
				"players": [],
				// board state 2x2 array [name, die, colors]
				"boardState":  result.boardState,
				"chatLog": []
				}

					//Data sent to player
					const gameData = {
						"method": "host",
						"game": games[gameId],
						"id": gameId,
						"boardState": games[gameId].boardState
					}
				//Send game id back to webpage
					connection.send(JSON.stringify(gameData));
				}


				if (result.method === "host-join"){
								
					hostKey = "host";
					const gameId = result.gameId;
					const playerId = result.playerId;
					const startCode = result.startCode;
					
					var counter = countForIds.filter(countForId => (countForId.id === gameId));
					console.log(counter);
					if ((counter.findIndex(entry => {return typeof counter === 'object'})) !== -1){
						var index = countForIds.findIndex((countForId => (countForId.id === gameId)));
						console.log("before update" + countForIds[index]);
						countForIds[index].i = countForIds[index].i - 2;
						console.log("after update" + countForIds[index]);
					}
					else {
						console.log("did not get gameId and update counter in host-join");
					}

					games[gameId] = {
						"id": gameId,
						"players": [],
						"boardState": result.boardState,
						"chatLog": [],
						"startCode": startCode
					}

					games[gameId].players.push({
						"playerId": playerId,
					})

					//if there is no game, return
					if(!games[gameId]) return;

					//Data sent to player
					const gameData = {
						"method": "host-join",
						"game": games[gameId],
						"id": gameId,
						"boardState": games[gameId].boardState,
						"chatLog": games[gameId].chatLog,
						"players": games[gameId].players,
						"startCode": startCode,
						"playerId": playerId

					}
										
					console.log("got number" + startCode);

										
					//Send game id back to webpage
					connection.send(JSON.stringify(gameData));

					//Announce new connections
					let chatMessage = players[playerId].username + " has started the game.";
					games[gameId].chatLog.push(chatMessage);
					const game2Data = {
						"method": "updateChat",
						"chatMessage": chatMessage
					}
					games[gameId].players.forEach( p => {
						players[p.playerId].connection.send(JSON.stringify(game2Data));
					})
					
					// if 2 players or more join, start game
					broadcastState();
				
										
					
				}
				
				//Join game server logic
				if (result.method === "join") {

					var username = result.username;
					playerId = result.playerId;
					players[playerId].username = username;
					hostKey = "not host";
					pId++;
					const gameId = result.gameId;
					const startCode = result.startCode;
						
							var counter = countForIds.filter(countForId => (countForId.id === gameId));
							console.log(counter);
							console.log("checkexist: " + counter.findIndex(entry => {return typeof counter === 'object'}));
							if ((counter.findIndex(entry => {return typeof counter === 'object'})) !== -1){
								var index = countForIds.findIndex((countForId => (countForId.id === gameId)));
								console.log("before update" + countForIds[index]);
								countForIds[index].i++;
								console.log("after update" + countForIds[index]);
							}
							else{
								countForIds.push({id: gameId, i: 1});
								console.log(countForIds);
							}

						
						console.log("got start: " + startCode);
						
						//if there is no game, return
						if(!games[gameId]) return;
					
					
						var counter = countForIds.filter(countForId => (countForId.id === gameId));
						console.log(counter);						
						if (counter.map(x => x.i) >= 1){
								games[gameId].players.push({
									"playerId": playerId
								});
								console.log("pushed player id" + counter);
						}
						else{
							console.log("check for error");
						}
					
						//Data sent to player to set up game
						const joinData = {
							"method": "join",
							"boardState": games[gameId].boardState,
							"chatLog": games[gameId].chatLog,
							"players": games[gameId].players,
							"id": gameId,
							"playerId": playerId,
							"startCode": startCode
						}
					
						checkForUpdatedGame();
						
					function checkForUpdatedGame(){
													
							if (games && gameId){						
								if (games[gameId].boardState[0]){
									
									var counter = countForIds.filter(countForId => (countForId.id === gameId));
									console.log(counter);
									if ((counter.findIndex(entry => {return typeof counter === 'object'})) !== -1){
										var index = countForIds.findIndex((countForId => (countForId.id === gameId)));
										console.log("before update" + countForIds[index]);
										countForIds[index].i--;
										console.log("after update" + countForIds[index]);
									}
																		
									// Add player to game
									games[gameId].players.push({
										"playerId": playerId
									});
									
									const joinData2 = {
										"method": "startGame",
										"boardState": games[gameId].boardState,
										"chatLog": games[gameId].chatLog,
										"players": games[gameId].players,
										"id": gameId,
										"playerId": playerId,
										"startCode": startCode
									}
									
									
									console.log("players in join1: " + Object.values(games[gameId].players));
									
									//Send game id back to webpage
									connection.send(JSON.stringify(joinData2));
									
									
									//Announce new connections
									let chatMessage = players[playerId].username + " has joined.";
									games[gameId].chatLog.push(chatMessage);
									const gameData = {
										"method": "updateChat",
										"chatMessage": chatMessage
									}
									games[gameId].players.forEach( p => {
										players[p.playerId].connection.send(JSON.stringify(gameData));
									}) 
																		
								}}
							
						var counter = countForIds.filter(countForId => (countForId.id === gameId));
						console.log(counter);
						if ((counter.findIndex(entry => {return typeof counter === 'object'})) !== -1){
							console.log(counter);
							if (counter.map(x => x.i) > 1){
									setTimeout(checkForUpdatedGame, 1500); 
							}
						}
						
													
					}

					// if 2 players or more join, start game
					broadcastState();
					players[playerId].connection.send(JSON.stringify(joinData));

				}		
				
			
				//Play game server logic
				if (result.method === "play") {

					//Itterates over the cards on the board, sends them to the statemachine to see
					//if action is permittable, if not it revertse change to old state.
					stateMac.dieCheck(result.boardState, games[result.gameId].boardState)

					playerId = result.playerId;
					const gameId = result.gameId;
					let chatMessage = null;
					let oldBoardState = games[gameId].boardState;
					let newBoardState = result.boardState;
					// Update log when a player makes a move
					// These for loops iterate over previous boardstate and compare it
					// to new boardstate to log specific changes.
					for(let i = 0; i < oldBoardState.length; ++i) {
						let oldMove = oldBoardState[i].moveMade;
						let newMove = newBoardState[i].moveMade;
						if(oldMove !== newMove) {
							chatMessage = players[playerId].username + " " + newMove;
						}					
					}
					games[gameId].boardState = result.boardState;
					if(chatMessage !== null) {
						games[gameId].chatLog.push(chatMessage);
						const gameData = {
							"method": "updateChat",
							"chatMessage": chatMessage
						}
						games[gameId].players.forEach( p => {
								players[p.playerId].connection.send(JSON.stringify(gameData));
								})
					}
				}

				// Send game information to player for download
				if(result.method == "download") {
					const gameId = result.gameId;
					playerId = result.playerId;
					const gameData = {
						"method": "download",
						"chatLog": games[gameId].chatLog
					}
					const con = players[playerId].connection;
					con.send(JSON.stringify(gameData));
				}

				// Update logs when someone types a message
				if(result.method === 'chat') {
					let gameId = result.gameId;
					let playerId = result.playerId;
					let chatMessage = result.chatMessage;
					chatMessage = players[playerId].username + ": " + chatMessage;
					games[gameId].chatLog.push(chatMessage);
					const gameData = {
						"method": "updateChat",
						"chatMessage": chatMessage
					}
					games[gameId].players.forEach( p => {
							players[p.playerId].connection.send(JSON.stringify(gameData));
							})
				}

				if(result.method === "exit") {

					const gameId = result.gameId;
					const playerId = result.playerId;
					if(players[playerId] === undefined)
						return;
					
<<<<<<< HEAD
					if(games[gameId] !== null && games[gameId] !== undefined) {
						for(let i = 0; i < games[gameId].players.length; i++){ 
=======
					// TODO remove player from players object
					console.log("before: " + Object.keys(players));
					delete players[playerId];
					console.log("after: " + Object.keys(players));
					if (games[gameId] !== null) {
						for (let i = 0; i < games[gameId].players.length; i++){ 
>>>>>>> e2e260d486b7f2ce5812b384e2cddd7baf5a67f4
							if (games[gameId].players[i].playerId === playerId) { 
								games[gameId].players.splice(i, 1); 
							}
						}
<<<<<<< HEAD
						if(games[gameId].players.length !== 0) {
							let chatMessage = players[playerId].username + " has left the game.";
=======

						if (games[gameId].players.length !== 0) {
							let chatMessage = "Player " + playerId + " has left the game.";
>>>>>>> e2e260d486b7f2ce5812b384e2cddd7baf5a67f4
							games[gameId].chatLog.push(chatMessage);
							const gameData = {
								"method": "updateChat",
								"chatMessage": chatMessage,
								"id": gameId
							}
														
							games[gameId].players.forEach( p => {
								players[p.playerId].connection.send(JSON.stringify(gameData));
								})

						}
						
						// TODO if there are no more players, end the game and remove from games object
						else {	
							console.log("IT IS GETTING HERE!")
			
							const gameData = {
								"method": "end",
								"id": gameId
							}
							
							console.log(gameData);
							//Send game id back to webpage
							connection.send(JSON.stringify(gameData));
							console.log("IT IS GETTING PAST THE CONNECTION SEND");
							
							delete games[gameId];
							console.log("IT IS GETTING PAST delete games[gameId]");
						}
						delete players[playerId];
					}

				} 




		})

		// generate player id
		if(playerId != 0 || hostKey === "not host"){
			playerId++;
		}

		players[playerId] = {
			"connection": connection
		}

		// data pack sent to player
		const gameData = {
			"method": "connect",
			"playerId": playerId
		}

		//pack up gameData to JSON string
		connection.send(JSON.stringify(gameData))

})



//Broadcasting function, broadcasts the gamestate to all players
function broadcastState(){

	for (const g of Object.keys(games)) {
		//update gamestate
		const game = games[g]

			const gameData = {
				"method": "update",
				"game": game
			}
		//Send updated game to all players
		game.players.forEach( p => {
				players[p.playerId].connection.send(JSON.stringify(gameData));
				})
	}

	setTimeout(broadcastState, 500);

}

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
	var port = parseInt(val, 10);

	if (isNaN(port)) {
		// named pipe
		return val;
	}

	if (port >= 0) {
		// port number
		return port;
	}

	return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
	if (error.syscall !== 'listen') {
		throw error;
	}

	var bind = typeof port === 'string'
		? 'Pipe ' + port
		: 'Port ' + port;

	// handle specific listen errors with friendly messages
	switch (error.code) {
		case 'EACCES':
			console.error(bind + ' requires elevated privileges');
			process.exit(1);
			break;
		case 'EADDRINUSE':
			console.error(bind + ' is already in use');
			process.exit(1);
			break;
		default:
			throw error;
	}
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
	var addr = httpServer.address();
	var bind = typeof addr === 'string'
		? 'pipe ' + addr
		: 'port ' + addr.port;
	debug('Listening on ' + bind);
}