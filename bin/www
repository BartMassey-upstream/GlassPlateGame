#!/usr/bin/env node

//Module dependencies.
var app = require('../app');
var debug = require('debug')('textexpress:server');

//Get port from environment and store in Express.
var port = normalizePort(process.env.PORT || '27000');
app.set('port', port);

//Create HTTP server.
//Library imports(http, express, websocket)
const http = require('http');
const websocketServer = require("websocket").server
var path = require('path');

//Express Start
//handled in app.js

//HTTP server start
const httpServer = http.createServer(app);
httpServer.listen(27000, () => console.log("Http on: 27000"));
httpServer.on('error', onError);
httpServer.on('listening', onListening);

//Variables
  // player id placeholder
  var pId = 1;
  var hostKey = "not host";
  //Objects for games and players used with their IDs as index
  const players = {};
  const games = {};

  // Include for function to create random game id and set to track all currently in use
  // game IDs (Rochele)
  var createGameId = require('../public/javascripts/createGameId');
  var inUseGameIds = new Set;

  //var StateMachine = require('javascript-state-machine');

  // Turn Http into WebSocket
  const wsServer = new websocketServer({
    "httpServer": httpServer,
  });

  //Run Websocket
  wsServer.on("request", request => {


    var playerId = pId;
    //var pId;

    //Binding TCP to connection
    const connection = request.accept(null, request.origin);

    //const connection = request.accept(null, request.origin);
    connection.on("close", () => {
      if(hostKey === "not host"){
        console.log("PlayerID: " + playerId + " disconnected.")}
      else {
        console.log("Created Game and Disconnected " + playerId)}
    });

    // receive message from the client here
    connection.on("message", message => {

      //Converts JSON message from the browser into javascript object using parse() method
      const result = JSON.parse(message.utf8Data)

      //Host game server logic
      if (result.method === "host") {
        //gets player id
        playerId = 0;

        // Generate unique game ID and add to inUseCode set (Rochele)
        // Will be removed upon end of game
        const gameId = createGameId.createGameId(inUseGameIds);
        inUseGameIds.add(gameId);

        hostKey = "host";

        games[gameId] = {
          "id": gameId,
          //Card amount in game hardcoded as of now
          "cards": 4,
          //the players connected to game stored in an array
          "players": [],
          // board state 2x2 array [name, die, colors]
          "boardState":  result.boardState
        }
        // print statements
        console.log(games[gameId])

        //Data sent to player
        const gameData = {
          "method": "host",
          "game": games[gameId],
          "id": gameId,
          "boardState": games[gameId].boardState
        }
        //Send game id back to webpage
        connection.send(JSON.stringify(gameData));
      }

      //Join game server logic
      if (result.method === "join") {

        playerId = result.playerId;
        hostKey = "not host";
        pId++;
        const gameId = result.gameId;

        //if there is no game, return
        if(!games[gameId]) return;

        //Data sent to player
        const gameData = {
          "method": "join",
          "game": games[gameId],
          "boardState": games[gameId].boardState
        }

        // if 2 players or more join, start game
        broadcastState();

        //adds a player to the game
        games[gameId].players.push({
          "playerId": playerId
        })
        //Announce new connections
        games[gameId].players.forEach( p => {
          players[p.playerId].connection.send(JSON.stringify(gameData));
        })


      }

      //Play game server logic
      if (result.method === "play") {

        playerId = result.playerId;
        const gameId = result.gameId;
        games[gameId].boardState = result.boardState;

      }
      
      // Send game information to player for download (Rochele)
      if(result.method == "download") {

        const gameId = result.gameId;
        playerId = result.playerId;

        //const playerId = result.playerId;
        const gameData = {
          "method": "download",
          "game": games[gameId]
        }

        const con = players[playerId].connection;
        //send gameData to client as JSON string
        con.send(JSON.stringify(gameData));
      }
    })

    // generate player id
    if(playerId != 0 || hostKey === "not host"){
      playerId++;
    }

    players[playerId] = {
    "connection": connection
    }

    // data pack sent to player
    const gameData = {
      "method": "connect",
      "playerId": playerId
    }

    //pack up gameData to JSON string
    connection.send(JSON.stringify(gameData))

  })


  //Broadcasting function, broadcasts the gamestate to all players
  function broadcastState(){

    for (const g of Object.keys(games)) {
      //update gamestate
      const game = games[g]

      const gameData = {
        "method": "update",
        "game": game
      }
      //Send updated game to all players
      game.players.forEach( p => {
        players[p.playerId].connection.send(JSON.stringify(gameData));
      })
    }

    setTimeout(broadcastState, 500);

  }

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
    }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
  var addr = httpServer.address();
  var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  debug('Listening on ' + bind);
}
